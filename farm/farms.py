import asyncio

import async_timeout

import farm.exploits
import farm.models as models
from backends.flag_submitter import AbstractFlagSubmitter
import re


class Farm:
    DEFAULT_ROUND_TIMEOUT = 60  # In seconds

    def __init__(self,
                 teams: [models.Team],
                 exploits: [farm.exploits.AbstractExploit],
                 flag_submitter: AbstractFlagSubmitter,
                 flag_format: str,
                 round_timeout=None):
        self.teams = teams
        self.exploits = exploits
        self.flag_submitter = flag_submitter
        self.flag_format = flag_format
        self._flag_re_str = re.compile(flag_format)
        self._flag_re_bytes = re.compile(flag_format.encode())
        self.round_timeout = self.DEFAULT_ROUND_TIMEOUT if round_timeout is None else round_timeout

    def run(self, loop=None):
        if loop is None:
            loop = asyncio.get_event_loop()
        loop.run_until_complete(self._run())

    async def _run(self):
        while True:
            try:
                await self._run_one_round()
            except Exception as e:
                # TODO (andgein): log the exception
                pass

    async def _run_one_round(self):
        with async_timeout.timeout(self.round_timeout):
            tasks = []
            for team in self.teams:
                for exploit in self.exploits:
                    tasks.append(self._run_exploit(team, exploit))

            while tasks:
                done, tasks = await asyncio.wait(tasks, return_when=asyncio.FIRST_COMPLETED)
                for task in done:
                    exploit_result = await task
                    flags = self._extract_flags(exploit_result)
                    await self.flag_submitter.send_flags(flags)

    async def _run_exploit(self, team, exploit):
        try:
            exploit.attack(team.vulnbox)
        except Exception as e:
            # TODO (andgein): log the exception
            pass

    def _extract_flags(self, exploit_result):
        if type(exploit_result) in [str, bytes]:
            exploit_result = [exploit_result]

        flags = []
        for line in exploit_result:
            if type(line) is bytes:
                line_flags = re.findall(self._flag_re_bytes, line)
            elif type(line) is str:
                line_flags = re.findall(self._flag_re_str, line)
            else:
                # TODO (andgein): log this invalid exploit's result
                pass

        return flags




