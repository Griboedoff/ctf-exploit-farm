import asyncio
import async_timeout
import re

import farm.exploits
import farm.models as models
from backends.flag_submitter import AbstractFlagSubmitter
from farm import defaults
from farm.configurator import Configurator
from farm.storage import AbstractFlagStorage
from farm.logging import Logger


class Farm:
    def __init__(self,
                 teams: [models.Team],
                 exploits: [farm.exploits.AbstractExploit],
                 flag_submitter: AbstractFlagSubmitter,
                 flag_storage: AbstractFlagStorage,
                 flag_format: str,
                 round_timeout=None,
                 submitter_sleep=None):
        self.teams = teams
        self.exploits = exploits
        self.flag_submitter = flag_submitter
        self.flag_storage = flag_storage
        self.flag_format = flag_format
        self._flag_re_str = re.compile(flag_format)
        self._flag_re_bytes = re.compile(flag_format.encode())
        self.round_timeout = defaults.ROUND_TIMEOUT if round_timeout is None else round_timeout
        self.submitter_sleep = defaults.SUBMITTER_SLEEP if submitter_sleep is None else submitter_sleep

        self._logger = Logger(self)

    @classmethod
    def create_from_configurator(cls, configurator: Configurator):
        return cls(
            configurator.get_teams(),
            configurator.get_exploits(),
            configurator.get_flag_submitter(),
            configurator.get_flag_storage(),
            configurator.get_flag_format(),
            configurator.get_round_timeout(),
            configurator.get_submitter_sleep(),
        )

    def run(self, loop=None):
        if loop is None:
            loop = asyncio.get_event_loop()

        task = asyncio.wait([self._run_exploits(), self._run_submitter()], loop=loop)
        loop.run_until_complete(task)

    async def _run_exploits(self):
        while True:
            try:
                await self._run_one_round()
            except asyncio.TimeoutError as e:
                # It's ok: just some exploit didn't finish him work
                pass
            except Exception as e:
                self._logger.error('Error occurred while running exploits: %s' % e, e)

    async def _run_one_round(self):
        with async_timeout.timeout(self.round_timeout):
            tasks = []
            for team in self.teams:
                for exploit in self.exploits:
                    tasks.append(self._run_exploit(team, exploit))

            while tasks:
                done, tasks = await asyncio.wait(tasks, return_when=asyncio.FIRST_COMPLETED)
                for task in done:
                    exploit_result = await task
                    # TODO (andgein): dump exploit output somewhere
                    flags = self._extract_flags(exploit_result)
                    if len(flags) > 0:
                        self._logger.info('Found flags in exploit output: [%s]' % ", ".join(map(str, flags)))
                        await self.flag_storage.add_flags(flags, "TODO: exploit name")

    async def _run_exploit(self, team, exploit):
        try:
            self._logger.info(f'Start exploit [{exploit}] on team [{team}]')
            return await exploit.attack(team.vulnbox)
        except Exception as e:
            self._logger.warning(f'Exception on running exploit [{exploit}] on team [{team}]: {e}')
            return ''

    def _extract_flags(self, exploit_result):
        if type(exploit_result) in [str, bytes]:
            exploit_result = [exploit_result]

        # TODO (andgein): log which exploit it was
        if not isinstance(exploit_result, (tuple, list)):
            self._logger.error('Exploit returned invalid result: %s, should be tuple, list, str or bytes, not %s' % (
                exploit_result,
                type(exploit_result)
            ))
            return []

        flags = []
        for line in exploit_result:
            if type(line) is bytes:
                line_flags = re.findall(self._flag_re_bytes, line)
            elif type(line) is str:
                line_flags = re.findall(self._flag_re_str, line)
            else:
                self._logger.error(
                    'Exploit returned invalid result in list: %s, should be str or bytes, not %s' % (
                        line,
                        type(line)
                    ))
                line_flags = []
            flags.extend(line_flags)

        return flags

    async def _run_submitter(self):
        while True:
            flags = await self.flag_storage.get_not_sent_flags()

            if len(flags) > 0:
                await self.flag_submitter.send_flags(flags)

            await asyncio.sleep(self.submitter_sleep)



